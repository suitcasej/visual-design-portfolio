{"ast":null,"code":"import { mix, progress, linear, circOut } from 'popmotion';\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\n\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n  var _a, _b, _c, _d;\n\n  if (shouldCrossfadeOpacity) {\n    target.opacity = mix(0, // (follow?.opacity as number) ?? 0,\n    // TODO Reinstate this if only child\n    (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1, easeCrossfadeIn(progress));\n    target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress));\n  } else if (isOnlyMember) {\n    target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress);\n  }\n  /**\n   * Mix border radius\n   */\n\n\n  for (var i = 0; i < numBorders; i++) {\n    var borderLabel = \"border\" + borders[i] + \"Radius\";\n    var followRadius = getRadius(follow, borderLabel);\n    var leadRadius = getRadius(lead, borderLabel);\n    if (followRadius === undefined && leadRadius === undefined) continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    /**\n     * Currently we're only crossfading between numerical border radius.\n     * It would be possible to crossfade between percentages for a little\n     * extra bundle size.\n     */\n\n    if (typeof followRadius === \"number\" && typeof leadRadius === \"number\") {\n      var radius = Math.max(mix(followRadius, leadRadius, progress), 0);\n      target[borderLabel] = radius;\n    }\n  }\n  /**\n   * Mix rotation\n   */\n\n\n  if (follow.rotate || lead.rotate) {\n    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress);\n  }\n}\n\nfunction getRadius(values, radiusName) {\n  var _a;\n\n  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n} // /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\n\n\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\n\nfunction compress(min, max, easing) {\n  return function (p) {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(progress(min, max, p));\n  };\n}\n\nexport { mixValues };","map":{"version":3,"sources":["/Users/jordanhodges/Projects/Portfolio/Portfolio/node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs"],"names":["mix","progress","linear","circOut","borders","numBorders","length","mixValues","target","follow","lead","shouldCrossfadeOpacity","isOnlyMember","_a","_b","_c","_d","opacity","easeCrossfadeIn","opacityExit","easeCrossfadeOut","i","borderLabel","followRadius","getRadius","leadRadius","undefined","radius","Math","max","rotate","values","radiusName","borderRadius","compress","min","easing","p"],"mappings":"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","sourcesContent":["import { mix, progress, linear, circOut } from 'popmotion';\n\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n    var _a, _b, _c, _d;\n    if (shouldCrossfadeOpacity) {\n        target.opacity = mix(0, \n        // (follow?.opacity as number) ?? 0,\n        // TODO Reinstate this if only child\n        (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1, easeCrossfadeIn(progress));\n        target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress));\n    }\n    else if (isOnlyMember) {\n        target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress);\n    }\n    /**\n     * Mix border radius\n     */\n    for (var i = 0; i < numBorders; i++) {\n        var borderLabel = \"border\" + borders[i] + \"Radius\";\n        var followRadius = getRadius(follow, borderLabel);\n        var leadRadius = getRadius(lead, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        /**\n         * Currently we're only crossfading between numerical border radius.\n         * It would be possible to crossfade between percentages for a little\n         * extra bundle size.\n         */\n        if (typeof followRadius === \"number\" &&\n            typeof leadRadius === \"number\") {\n            var radius = Math.max(mix(followRadius, leadRadius, progress), 0);\n            target[borderLabel] = radius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (follow.rotate || lead.rotate) {\n        target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress);\n    }\n}\nfunction getRadius(values, radiusName) {\n    var _a;\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\nfunction compress(min, max, easing) {\n    return function (p) {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\n\nexport { mixValues };\n"]},"metadata":{},"sourceType":"module"}